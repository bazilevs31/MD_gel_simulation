#!/usr/bin/env python

# Program: AnalyzeCrystYamamoto.py
# Purpose: analyzes crystallinity using AnalyzeCrystYamamoto
# Author:  Triandafilidi Vasiliy , MSc student at CHBE UBC, Vancouver
# e-mail:  vtriandafilidi(at)chbe(dot)ubc(dot)ca
# Syntax:  python AnalyzeCrystYamamoto.py -h for help,
# Requires: read_parameters.py, save_plot

# Theory:
# two ways of writing the alghorithm
# look for the neighbours of every bond
# or, alternatively, to look for the mesh and take the bonds from the mesh
# i will use the second approach it will be faster
# alghorithm:`
# divide the mesh in to regions by the means of MDAnalysis


# Copyright (c) 2014 Vasiliy Triandafilidi
# Released under the GNU Public Licence, v2 or any higher version

import numpy as np
import MDAnalysis
import AnalyzeChain
import read_parameters
import save_plots
import get_path_names
import AnalyzeLog
import numba

import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D


@numba.jit(nopython=True)
def get_cryst(bonds, alignment_vector, threshold):
    """
    input: bonds, alignment_vector, threshold
    output: cryst


    bonds : numpy array of (N,3) of normalized bonds vectors of a selected
    domain
    alignment_vector: eigen vector, which corresponds to orientation of
    selected bonds, by which they will be compared with
    cryst: crystallinity of the region, analyzed by alignment

    then calculate the number of bonds that are aligned
    to the average direction alignment_vector
    then look at the percentage of the bonds which are within certain threshold
    """
    Nbonds = bonds.shape[0]
    k = 0
    cryst, P2, cos = 0.0, 0.0, 0.0
    for i in range(Nbonds):
        cos = 0.
        tmp = 0.0
        for j in range(3):
            tmp = alignment_vector[j]*bonds[i, j]
            cos += tmp
        # cos = np.dot(alignment_vector, bonds[i])
        # print cos
        # cos = 0.
        P2 = (3.*cos**2.0 - 1.)/2.
        if P2 > threshold:
            k += 1
            # print "k is larger", k
    # print "k = ", k
    if k > 0:
        # print "k = ", k
        cryst = float(k)/float(Nbonds)
        # print "crystallinity" , cryst
    elif k == 0:
        cryst = 0.
    return cryst

def get_eigvec(bonds):
    """
    input: bonds
    output: local_chains_eigvec

    bonds : numpy array of (N,3) of normalized bonds vectors of a selected
    domain
    local_chains_eigvec: eigen vector, which corresponds to orientation of
    selected bonds

    generates a qab tensor of outer products
    gets uses coor of all bonds generated by get_bondlist_coords
    returns local_chains_eigvec - array eigen vectors that show
     the alignment directions of chains
    """

    # Nbonds=bonds.shape[0]
    dij = np.eye(3, dtype=np.float32)
    dij /= 2.0
    nq = bonds.shape[0]
    qab = np.einsum('ij,ik->jk', bonds, bonds)
    qab *= float(3.0/(2.0*nq))
    qab -= dij
    vals, vecs = np.linalg.eig(qab)
    local_chains_eigvec = vecs[:, 0]
    return local_chains_eigvec

# @profile
def main():
    args = read_parameters.read_traj_vmd()
    print args
    u = MDAnalysis.Universe(args.psffile, args.traj)
    psffile = get_path_names.get_filename(u.filename)
    n_atoms_per_box = args.nAtomsPerBox
    Natoms = u.trajectory.numatoms
    Nx_atoms = Natoms**(1./3.) # how many atoms in a line
    Nsub = int(Nx_atoms / float(n_atoms_per_box)) # how many segements of 3 atoms
    cryst_all = 0.0
    # box = u.trajectory.ts.dimensions[:-3]
    # length_x = box[-1]
    u.SYSTEM.packIntoBox()
    a = u.selectAtoms("all")
    c = a.coordinates()
    print c
    length_x = a.bbox().max()
    grid_1d = np.linspace(0.0, length_x, Nsub+1, endpoint=True)
    delta = grid_1d[1] - grid_1d[0]
    frame = []
    g2 = []

    if args.filedumpskip:
        dumpskip = AnalyzeLog.get_dumpskip(filename='dumpskip.txt',
                                           keyparameter="dump" +
                                           args.keyparameter+"skip")
        # dumpskip = args.dumpskip
        timestep = AnalyzeLog.get_timestep(filename='dumpskip.txt',
                                           keyparameter="time" +
                                           args.keyparameter
                                           + "step")
    else:
        print "using given parameters"
        dumpskip = args.dumpskip
        timestep = args.timestep

    # decide the skipping information
    if args.auto_traj_skip:
        trajskip = int(u.trajectory.numframes/120.)
        if trajskip < 1:
            trajskip = 1
    elif args.auto_traj_skip:
        trajskip = args.trajskip
    else:
        raise ValueError("trajskip needs to be provided")
    for ts in u.trajectory[args.startframe:args.endframe:trajskip]:
        # ar_z is a planar selection
        u.SYSTEM.packIntoBox()
        for i, z in enumerate(grid_1d[0:-1]):
            ar_z = u.selectAtoms("prop  z >= "
                                 + str(z) +
                                 "  and  prop z < "
                                 + str(z+delta))
            # print " I am in z ", z
            # print len(ar_z)
            # ater this step ar_y is a line
            for j, y in enumerate(grid_1d[0:-1]):
                ar_y = ar_z.selectAtoms("prop  y >= "
                                        + str(y) +
                                        "  and  prop y < "
                                        + str(y+delta))
                # print " I am in y ", y
                # print len(ar_y)
                # ater this step ar_x is a dot
                for k, x in enumerate(grid_1d[0:-1]):
                    ar_x = ar_y.selectAtoms("prop  x >= "
                                            + str(x)
                                            + "  and  prop x < "
                                            + str(x+delta))
                    # print " I am in x ", x
                    # print len(ar_x)
                    bonds = AnalyzeChain.get_bondlist_coords(ar_x)
                    cryst_all += get_cryst(bonds, get_eigvec(bonds),
                                           threshold=args.threshold)
        frame.append(ts.frame)
        cryst_all /= float(Nsub**3.0)

        g2.append(cryst_all)
        print "frame ", ts.frame, " cryst = ", cryst_all
    frame = np.array(frame)
    g2 = np.array(g2)
    # os.system("convert -delay ")

    save_plots.save_plot(frame, g2,
                         plotname='YC',
                         name=psffile,
                         logplot=args.logplot,
                         dumpskip=dumpskip,
                         timestep=timestep)
    return None


if __name__ == '__main__':
    main()
